\documentclass[a4paper,10pt,oneside,openany,final,article]{memoir}
\input{common}
\settocdepth{chapter}
\usepackage{minted}
\usepackage{fontspec}
\setromanfont{Source Serif Pro}
\setsansfont{Source Sans Pro}
\setmonofont{Source Code Pro}
\usepackage{draftwatermark}
\SetWatermarkText{\textsc{DRAFT}}
\SetWatermarkColor[gray]{0.9}

\begin{document}
\title{A view of $0$ or $1$ elements: \tcode{views::nullable}}
\author{
Steve Downey \small(\href{mailto:sdowney@gmail.com}{sdowney@gmail.com}) \\
}
\date{} %unused. Type date explicitly below.
\maketitle

\begin{flushright}
\begin{tabular}{ll}
  Document \#: & D1255R13 \\
  Date: & \today \\
  Project: & Programming Language C++ \\
  Audience: & LEWG
\end{tabular}
\end{flushright}

\begin{abstract}
  This paper proposes a range adaptor \tcode{views::nullable} which adapts nullable types---such as \tcode{std::optional} or pointer to object types---into a range of the underlying type.
\end{abstract}

\tableofcontents*

\chapter*{Changes Since Last Version}

\begin{itemize}
\item \textbf{Changes since R12},
  \begin{itemize}
  \item Removal of views::maybe in favor of range optional
  \item \tcode{std::maybe} concept
  \item Free functions on \tcode{maybe} types such as optional and pointers.
  \end{itemize}
\item \textbf{Changes since R12},
  \begin{itemize}
  \item Paper system issues---No text changes over R11
  \end{itemize}
\end{itemize}

\chapter{Before / After Table}
\begin{tabular}{ lr }
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize=\scriptsize]{c++}
auto opt = possible_value();
if (opt) {
    // a few dozen lines ...
    use(*opt); // is *opt Safe ?
}


\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\scriptsize]{c++}

for (auto&& opt :
     views::nullable(possible_value())) {
    // a few dozen lines ...
    use(opt); // opt is Safe
}

\end{minted}
\end{minipage}
\\ \midrule
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize =\scriptsize]{c++}

std::optional o{7};
if (o) {
    *o = 9;
    std::cout << "o=" << *o << " prints 9\n";
}
std::cout << "o=" << *o << " prints 9\n";

\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\scriptsize]{c++}

std::optional o{7};
for (auto&& i
    : views::nullable_view<std::optional<int>&>(o)) {
    i = 9;
    std::cout << "i=" << i << " prints 9\n";
}
std::cout << "o=" << *o << " prints 9\n";

// if range for is too much magic
if (auto v = views::nullable_view<std::optional<int>&>(o);
    std::begin(v) != std::end(v)) {
    auto itr = std::begin(v);
    *itr     = 10;
    std::cout << "*itr=" << *itr << " prints 10\n";
}
std::cout << "o=" << *o << " prints 10\n";

\end{minted}
\end{minipage}
\\ \midrule
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\scriptsize]{c++}
std::vector<int> v{2, 3, 4, 5, 6, 7, 8, 9, 1};
auto test = [](int i) -> std::optional<int> {
    switch (i) {
    case 1:
    case 3:
    case 7:
    case 9:
        return i;
    default:
        return {};
    }
};

auto&& r = v | ranges::views::transform(test) |
           ranges::views::filter(
               [](auto x) { return bool(x); }) |
           ranges::views::transform(
               [](auto x) { return *x; }) |
           ranges::views::transform([](int i) {
               std::cout << i;
               return i;
           });
for (auto&& i : r) {
};

\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\scriptsize]{c++}
std::vector<int> v{2, 3, 4, 5, 6, 7, 8, 9, 1};
auto test = [](int i) -> std::optional<int> {
    switch (i) {
    case 1:
    case 3:
    case 7:
    case 9:
        return i;
    default:
        return {};
    }
};

auto&& r =
    v | ranges::views::transform(test) |
    ranges::views::transform(views::nullable) |
    ranges::views::join |
    ranges::views::transform([](int i) {
        std::cout << i;
        return i;
    });
for (auto&& i : r) {
};

\end{minted}
\end{minipage}
  \\ \midrule
\begin{minipage}[t]{0.45\columnwidth}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\scriptsize]{c++}
std::vector<int> v{2, 3, 4, 5, 6, 7, 8, 9, 1};

auto test = [](int i) -> optional<int> {
    switch (i) {
    case 1:
    case 3:
    case 7:
    case 9:
        return optional{i};
    default:
        return optional<int>{};
    }
};

auto&& r = v | ranges::views::transform(test) |
           ranges::views::join |
           ranges::views::transform([](int i) {
               std::cout << i;
               return i;
           });
for (auto&& i : r) {
};
\end{minted}
\end{minipage}

\end{tabular}

\chapter{Motivation}

In writing range transformation it is useful to be able to lift a value into a view that is either empty or contains the value. \tcode{std::optional} fills this function. For nullable types, types which model \tcode{maybe}, constructing an empty view for disengaged values and providing a view to the underlying value is useful as well.

\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}{c++}
    int fortytwo = 42;
    int sixbynine = 54;

    std::vector<int*> v{&fortytwo, nullptr, &sixbynine};

    auto r = std::views::join(std::views::transform(v, views::nullable));

    for (auto i : r) {
        std::cout << i << '\t'; // prints 42 and 54 skipping the nullptr
    }
    std::cout << std::endl;

  \end{minted}
\end{minipage}

The \tcode{maybe} protocol that \tcode{views::nullable} adapts is inherently unsafe because it models unsafe pointer semantics. If a nullable type is disengaged, using the derefence operator \tcode{operator*()} is undefined behavior, in practice reading from a union with the wrong type engaged. The allowed operations of \mintinline{C++}{views::nullable} are all, in themselves, safe, and using the adapter can lead to safer code.

An example is using \mintinline{C++}{views::nullable} in range based for loops, allowing the contained nullable value to not be dereferenced within the body. This is of small value in small examples in contrast to testing the nullable in an if statement, but with longer bodies the dereference is often far away from the test. This can be a particular issue in doing code reviews where the test, if it exists, is not visible. Often the first line in the body of the \mintinline{C++}{if} is naming the dereferenced nullable, and lifting the dereference into the \tcode{for} loop eliminates some boilerplate code, the same way that range based \tcode{for} loops do.

\begin{minipage}[t]{\columnwidth}
\begin{minted} {c++}
{
    auto opt = possible_value();
    if (opt) {
        // a few dozen lines ...
        use(*opt); // is *opt Safe ?
    }
}

for (auto&& opt :
     views::nullable(possible_value())) {
    // a few dozen lines ...
    use(opt); // opt is Safe
}

\end{minted}
\end{minipage}


Of course, if the \tcode{maybe} is empty, there is nothing in the view to act on.

\begin{minipage}[t]{\columnwidth}
\begin{minted} {c++}

auto oe = std::optional<int>{};
for (int i : views::nullable(oe))
    std::cout << "i=" << i
              << '\n'; // does not print

\end{minted}
\end{minipage}

Converting an optional type into a view can make APIs that return optional types, such as lookup operations, easier to work with in range pipelines.

\begin{minipage}[t]{\columnwidth}
\begin{minted} {c++}

std::unordered_set<int> set{1, 3, 7, 9};

auto flt = [=](int i) -> std::optional<int> {
    if (set.contains(i))
        return i;
    else
        return {};
};

for (auto i : ranges::iota_view{1, 10} |
                  ranges::views::transform(flt)) {
    for (auto j : views::nullable(i)) {
        for (auto k : ranges::iota_view(0, j))
            std::cout << '\a';
        std::cout << '\n';
    }
}

\end{minted}
\end{minipage}



\chapter{Borrowed Range}

A \tcode{borrowed_range} is one whose iterators cannot be invalidated by ending the lifetime of the range.

The reference specializations of \tcode{nullable_view} are borrowed. Iterators refer to the underlying object directly.

All instantiations of \tcode{nullable_view} over a pointer to object are borrowed ranges. The iterator refers to the address of the object pointed to without involving any addresss in the view.

A \tcode{nullable_view<shared_ptr>}, however, is not a borrowed range, as it participates in ownership of the \tcode{shared_ptr} and might invalidate the iterators if upon the end of its lifetime it is the last owner.

An example of code that is enabled by borrowed ranges, if unlikely code:

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}
    num = 42;
    int k = *std::ranges::find(views::nullable(&num), num);
  \end{minted}
\end{minipage}

Providing the facility is not a significant cost, and conveys the semantics correctly, even if the simple examples are not hugely motivating. In particular there is no real implementation impact, other than providing template variable specializations for enable_borrowed_range.


\chapter{Monadic Operations}
It is not feasible to give \tcode{nullable_view} a direct monadic interface as it would require, for example, construction of a type that dereferences to \tcode{U} to support \tcode{transform} over \tcode{T -> U}, but that is not in general possible in the C++ type system. The additional level of indirection built in to \tcode{nullable_view} makes this infeasible.


\section{Reference Specialization}
Having worked with the \tcode{reference_wrapper} support for some time, the ergonomics are somewhat lacking. In addition, many of the Big Dumb Business Objects that are the result of lookups, or filters, and are thus good candidates for optionality, are also not good at move operations, having dozens of individual members that are a mix of primitives, strings, and sub-BDOs, resulting in complex move constructors. In addition, many old and well tested functions will mutate these objects, rather than making copies, using a more object oriented than value oriented style.

For these reasons, supporting the common case of reference semantics ergonomically is important. Folding the implementation of \tcode{reference_wrapper} into a template specialization for \tcode{T\&} provides good ergonomics. The type  \tcode{nullable_view} does not support assignment from the underlying type, so the only question for semantics is assignment from another instance of the same type. The semantics of \tcode{std::reference_wrapper} are well established and correct, where the implementation pointer is reassigned, putting the assignee into the same state as the assigned. These are the same semantics currently proposed for \tcode{optional<T\&>}.

The range adaptor \tcode{views::nullable} only produces the non-reference specialization. As range code is strongly rooted in value semantics, providing reference semantics without ceremony seems potentially dangerous. Having it dependent on the value category of the expression would make it far too easy to produce reference types that would dangle. If the pattern becomes common, providing an instance of the function object with a distinct name would be non-breaking for anyone. Using the constructor form is not a particular burden.

This means that all of the operations on \tcode{nullable_view} are directly safe. To construct a non-safe operation is possible, but looks unsafe in code. For example:

\begin{minipage}[t]{\columnwidth}
  \begin{minted}{c++}
nullable_view<int> o1{42};
// ...
assert(*(o1.data()) == 42));
  \end{minted}
\end{minipage}

Dereferencing the result of \tcode{data()} without a check for null is of course unsafe, but in a way that should be visible to programmers, reviewers,  and tools.

\chapter{Design}

The type \tcode{nullable_view} has the semantics of zero or one objects based on if the underlying nullable object does or does not have a value, as indicated by the \tcode{maybe} being truthy or falsy.

\chapter{Freestanding}

The type \tcode{nullable_view} naturally meets the requirements for freestanding.

\chapter{Implementation}

A publicly available implementation at \url{https://github.com/steve-downey/view_maybe}. There are no particular implementation difficulties or tricks. The declarations are essentially what is quoted in the Wording section and the implementations are described as effects.

\chapter{Proposal}

Add a range adaptor object

  \tcode{views::nullable} a range adaptor over a \tcode{nullable_object} producing a view into the nullable object.

A \tcode{maybe} object is one that is both contextually convertible to bool and for which the type produced by dereferencing is an equality preserving object. Non void pointers, \tcode{std::optional}, and the proposed \tcode{std::expected} \cite{P0323R9} types all model \exposid{maybe}. Function pointers do not, as functions are not objects. Iterators do not generally model \exposid{maybe}, as they are not required to be contextually convertible to bool.

The generic type \tcode{std::nullable_view}, which is produced by \tcode{views::nullable} is further specialized over reference types, such that operations on the iterators of the range modify the object the range is over, if and only if the object exists.


\chapter{Wording}


\begin{wording}


Modify 26.2 Header <ranges> synopsis

\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{adjustwidth}{1cm}{1cm}
  \begin{addedblock}
    \begin{codeblock}
// \ref{range.nullable}, nullable view
template<typename T>
requires @\seebelow@;
class nullable_view;                                       // freestanding

template<class T>
constexpr bool
@\libspec{enable_borrowed_range}{nullable_view}@<nullable_view<T*>> = true;  // freestanding

template<class T>
constexpr bool
@\libspec{enable_borrowed_range}{nullable_view}@<nullable_view<T&>> = true;  // freestanding

namespace views {
  inline constexpr @\unspec@ nullable = @\unspec@;          // freestanding
}



    \end{codeblock}
  \end{addedblock}
\end{adjustwidth}


\Sec2[range.nullable]{Nullable View}

\Sec3[range.nullable.overview]{Overview}

\pnum
\tcode{nullable_view} is a range adaptor that produces a \libconcept{view} with cardinality 0 or 1. It adapts object types which model the exposition only concept \libconcept{nullable_object_val} or \libconcept{nullable_object_ref}.


\pnum
\indexlibrarymember{nullable}{views}%
The name \tcode{views::nullable} denotes a
customization point object\iref{customization.point.object}.
Given a subexpression \tcode{E}, the expression
\tcode{views::nullable(E)} is expression-equivalent to
\tcode{nullable_view<decay_t<decltype((E))>>(E)}.

\Sec3[range.nullable.view]{Class template \tcode{nullable_view}}

\begin{example}
  \begin{codeblock}
    optional o{4};
    for (int k : nullable_view m{o})
      cout << k;        // prints \tcode{4}
  \end{codeblock}
\end{example}

\Sec3[range.nullable.view]{Class template \tcode{nullable_view}}

\begin{codeblock}
namespace std::ranges {
  template<class I>
  concept @\exposconceptnc{readable_references}@ = @\seebelownc@;  // \expos

  template<class I>
    concept @\exposconceptnc{nullable_object}@ = @\seebelownc@;  // \expos

  template<class I>
    concept @\exposconceptnc{nullable_object_val}@ = @\seebelownc@;  // \expos

  template<class I>
    concept @\exposconceptnc{nullable_object_ref}@ = @\seebelownc@;    // \expos

  template <typename Nullable>
    requires(@\libconcept{copyable_object}@<Nullable> &&
      (@\libconcept{nullable_object_val}@<Nullable> || @\libconcept{nullable_object_ref}@<Nullable>))
  class nullable_view<Nullable>
    : public ranges::view_interface<nullable_view<Nullable>> {
  private:
    using T = remove_reference_t<
        iter_reference_t<typename unwrap_reference_t<Nullable>>>;

    @\exposidnc{movable-box}@<Nullable> @\exposidnc{value_}@; // \expos{} (see \ref{range.move.wrap})

  public:
    constexpr nullable_view() = default;

    constexpr explicit nullable_view(Nullable const& nullable);

    constexpr explicit nullable_view(Nullable&& nullable);

    template <class... Args>
        requires constructible_from<Nullable, Args...>
    constexpr nullable_view(in_place_t, Args&&... args);

    constexpr T*       begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T*       end() noexcept;
    constexpr const T* end() const noexcept;

    constexpr size_t size() const noexcept;

    constexpr auto data() noexcept;

    constexpr const auto data() const noexcept;

    friend constexpr auto operator<=>(const nullable_view& l,
                                      const nullable_view& r);

    friend constexpr bool operator==(const nullable_view& l,
                                     const nullable_view& r);
};

\end{codeblock}

\pnum
The exposition-only \defexposconcept{readable_references} concept is equivalent to:
\begin{itemdecl}
  template<class Ref, class ConstRef>
  concept @\defexposconcept{readable_references}@ =               // \expos
  is_lvalue_reference_v<Ref> &&
  is_object_v<remove_reference_t<Ref>> &&
  is_lvalue_reference_v<ConstRef> &&
  is_object_v<remove_reference_t<ConstRef>> &&
  convertible_to<add_pointer_t<ConstRef>, const remove_reference_t<Ref>*>;

\end{itemdecl}


\pnum
The exposition-only \defexposconcept{nullable_object} concept is equivalent to:
\begin{itemdecl}
  template<class I>
  concept @\defexposconcept{nullable_object}@ =               // \expos
  is_object_v<I> && requires(I& t, const I& ct) {
    bool(t);
    bool(ct);
    *(t);
    *(ct);
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
When an object is contextually convertible to \tcode{bool} and dereferencable via \tcode{operator \ast()}, the object is said to be \term{nullable}.

\end{itemdescr}

\pnum
The exposition-only \defexposconcept{nullable_object_val} concept is equivalent to:
\begin{itemdecl}
  template<class I>
  concept @\defexposconcept{nullable_object_val}@ =               // \expos
  @\libconcept{nullable_object}@<T>
    && @\libconcept{readable_references}@<iter_reference_t<T>, iter_reference_t<const T>>;

\end{itemdecl}

\begin{itemdescr}
\pnum
When an object is contextually convertible to \tcode{bool} and dereferencable via \tcode{operator \ast()}, the object is said to be a \term{nullable object}.

\end{itemdescr}

\pnum
The exposition-only \defexposconcept{nullable_object_ref} concept is equivalent to:
\begin{itemdecl}
  template<class I>
  concept @\defexposconcept{nullable_object_ref}@ =               // \expos
  @\libconcept{is-ref-wrapper}@<I>
     && @\libconcept{nullable_object_val}@<typename I::type>;

\end{itemdecl}

\indexlibraryctor{nullable_view}%

\pnum
\begin{itemdecl}
constexpr explicit nullable_view();
\end{itemdecl}
\begin{itemdescr}
\pnum{}
\effects{}
Initializes \exposid{value_} with \tcode{nullptr}
\end{itemdescr}

\begin{itemdecl}
constexpr explicit nullable_view(Nullable nullable);
\end{itemdecl}
\begin{itemdescr}
\pnum{}
\effects{}
Initializes \exposid{value_} with \tcode{addressof(nullable)}
\end{itemdescr}

\begin{itemdecl}
constexpr T* begin() noexcept;
constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{data();}
\end{itemdescr}

\begin{itemdecl}
constexpr T* end() noexcept;
constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum{}
\returns \tcode{data() + size();}.
\end{itemdescr}

\begin{itemdecl}
static constexpr size_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum{}
\effects{}
Equivalent to:

\begin{codeblock}
if (!@\exposid{value_}@)
  return 0;
Nullable& m = *@\exposid{value_}@;
return bool(m);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum{}
\effects{}
Equivalent to:
\begin{codeblock}
if (!@\exposid{value_}@)
  return nullptr;
const Nullable& m = *@\exposid{value_}@;
return m ? addressof(*m) : nullptr;
\end{codeblock}
\end{itemdescr}



\Sec3[range.nullable.view.ref]{Class template specialization \tcode{nullable_view<T\&>}}

\begin{codeblock}
template <typename Nullable>
  requires(movable_object<Nullable> &&
             (nullable_object_val<Nullable> || nullable_object_ref<Nullable>))
class nullable_view<Nullable&>
    : public ranges::view_interface<nullable_view<Nullable>> {
  private:
    using T = remove_reference_t<
        iter_reference_t<typename unwrap_reference_t<Nullable>>>;

    Value* @\exposidnc { value_ }@; // \expos{}

  public:
    constexpr nullable_view() : value_(nullptr){};

    constexpr explicit nullable_view(Nullable& nullable);

    constexpr explicit nullable_view(Nullable&& nullable) = delete;

    constexpr T*       begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T*       end() noexcept;
    constexpr const T* end() const noexcept;

    constexpr size_t size() const noexcept;

    constexpr T* data() noexcept;

    constexpr const T* data() const noexcept;
};

\end{codeblock}



\indexlibraryctor{nullable_view}%

\pnum
\begin{itemdecl}
  constexpr explicit nullable_view();
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes \exposid{value_} with \tcode{nullptr}
\end{itemdescr}

\begin{itemdecl}
  constexpr explicit nullable_view(Nullable nullable);
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes \exposid{value_} with \tcode{addressof(nullable)}
\end{itemdescr}


\begin{itemdecl}
constexpr explicit nullable_view(Nullable&& nullable) = delete;
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  Deleted
\end{itemdescr}

\begin{itemdecl}
  constexpr T* begin() noexcept;
  constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{data();}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* end() noexcept;
  constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns
  \tcode{data() + size();}.
\end{itemdescr}

\begin{itemdecl}
  static constexpr size_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    if (!@\exposid{value_}@)
      return 0;
    return bool(*@\exposid{value_}@);
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* data() noexcept;
  constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum{}
\effects{}
Equivalent to:
\begin{codeblock}
  if (!@\exposid{value_}@)
    return nullptr;
  return *@\exposid{value_}@ ? addressof(**@\exposid{value_}@) : nullptr;
\end{codeblock}
\end{itemdescr}

\Sec2[version.syn]{Feature-test macro}
Add the following macro definition to [version.syn], header <version> synopsis, with the value selected by the editor to reflect the date of adoption of this paper:

\begin{codeblock}
  #define __cpp_lib_ranges_nullable 20XXXXL // also in <ranges>, <tuple>, <utility>
\end{codeblock}

\end{wording}

\chapter{Impact on the standard}

A pure library extension, affecting no other parts of the library or language.

The proposed changes are relative to the current working draft~\cite{N4958}.

\chapter*{Document history}

\begin{itemize}
\item \textbf{R12},
  \begin{itemize}
  \item Paper system title issues - no text changes
  \end{itemize}
\item \textbf{Changes since R11},
  \begin{itemize}
  \item Expand on design and implementation details
  \item Monadic functions use deducing \tcode{this}
  \item Constraints, Mandates, Returns, Effects clean up
  \end{itemize}
\item \textbf{Changes since R10},
  \begin{itemize}
  \item Complete History in history section
  \item exposid formatting and ampersand escaping TeX formatting nits
  \end{itemize}
\item \textbf{Changes since R9},
  \begin{itemize}
  \item Fix Borrowed Ranges post naming split
  \item Clarify safety concerns
  \end{itemize}
\item \textbf{Changes since R8},
  \begin{itemize}
  \item Give maybe and nullable distinct template names
  \item Propose T\& specializations
  \item Propose monadic interface for maybe_view
  \item Wording++
  \item Freestanding
  \end{itemize}
\item \textbf{Changes since D7}, presented to SG9 on 2022.07.11
  \begin{itemize}
  \item Layout issues
  \item References include paper source
  \item Citation abbreviation form to `abstract'
  \item `nuulable' typo fix
  \item Markdown backticks to tcode
  \item ToC depth and chapter numbers for Ranges
  \item No technical changes to paper --- all presentation
  \end{itemize}
\item \textbf{Changes since R7}
  \begin{itemize}
  \item Update all Wording.
  \item Convert to standards latex macros for wording.
  \item Removed discussion of list comprehension desugaring - will move to yield_if paper.
  \end{itemize}
\item \textbf{Changes since R6}
  \begin{itemize}
  \item Extend to all object types in order to support list comprehension
  \item Track working draft changes for Ranges
  \item Add discussion of _borrowed_range_
  \item Add an example where pipelines use references.
  \item Add support for proxy references (explore std::pointer_traits, etc).
  \item Make std::views::maybe model std::ranges::borrowed_range if it's not holding the object by value.
  \item Add a const propagation section discussing options, existing precedent and proposing the option that the author suggests.
  \end{itemize}
\item \textbf{Changes since R5}
  \begin{itemize}
  \item Fix reversed before/after table entry
  \item Update to match C++20 style [@N4849] and changes in Ranges since [@P0896R3]
  \item size is now size_t, like other ranges are also
  \item add synopsis for adding to `<ranges>` header
  \item Wording clean up, formatting, typesetting
  \item Add implementation notes and references
  \end{itemize}
\item \textbf{Changes since R4}
  \begin{itemize}
  \item Use std::unwrap\_reference
  \item Remove conditional `noexcept`ness
  \item Adopted the great concept renaming
  \end{itemize}
\item \textbf{Changes since R3}
  \begin{itemize}
  \item Always Capture
  \item Support reference\_wrapper
  \end{itemize}
\item \textbf{Changes since R2}
  \begin{itemize}
  \item Reflects current code as reviewed
  \item Nullable concept specification
  \item Remove Readable as part of the specification, use the useful requirements from Readable
  \end{itemize}
  \begin{itemize}
  \item Wording for views::maybe as proposed
  \item Appendix A: wording for a view\_maybe that always captures
  \end{itemize}
\item \textbf{Changes since R1}
  \begin{itemize}
  \item Refer to views::all
  \item Use wording 'range adaptor object'
  \end{itemize}
\item \textbf{Changes since R0}
  \begin{itemize}
  \item Remove customization point objects
  \item Concept `Nullable`, for exposition
  \item Capture rvalues by decay copy
  \item Remove maybe\_view as a specified type
  \end{itemize}
\end{itemize}

\renewcommand{\bibname}{References}
\bibliographystyle{abstract}
\bibliography{wg21,mybiblio}

\nocite{viewmayb27:online}

\end{document}
