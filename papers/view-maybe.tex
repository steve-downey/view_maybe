\documentclass[a4paper,10pt,oneside,openany,final,article]{memoir}
\input{common}
\settocdepth{chapter}
\usepackage{minted}
\usepackage{fontspec}
\setromanfont{Source Serif Pro}
\setsansfont{Source Sans Pro}
\setmonofont{Source Code Pro}
\usepackage{draftwatermark}
\SetWatermarkText{\textsc{DRAFT}}
\SetWatermarkColor[gray]{0.9}

\begin{document}
\title{A view of $0$ or $1$ elements: \tcode{views::maybe}}
\author{
Steve Downey \small(\href{mailto:sdowney@gmail.com}{sdowney@gmail.com}) \\
}
\date{} %unused. Type date explicitly below.
\maketitle

\begin{flushright}
\begin{tabular}{ll}
  Document \#: & D1255R9 \\
  Date: & \today \\
  Project: & Programming Language C++ \\
  Audience: & SG9, LEWG
\end{tabular}
\end{flushright}

\begin{abstract}
  This paper proposes two range adaptors which produce a view with cardinality $0$ or $1$
  \begin{itemize}
  \item
    \tcode{views::maybe} a range adaptor that produces an owning view holding $0$ or $1$ elements of an object
  \item
    \tcode{views::nullable} which adapts nullable types---such as \tcode{std::optional} or pointer to object types---into a range of the underlying type.
  \end{itemize}
\end{abstract}

\tableofcontents*

\chapter{Before / After Table}
\begin{tabular}{ ll }
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize=\footnotesize]{c++}
{
    auto opt = possible_value();
    if (opt) {
        // a few dozen lines ...
        use(*opt); // is *opt OK ?
    }
  }

\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\footnotesize]{c++}

for (auto&& opt :
     views::nullable(possible_value())) {
    // a few dozen lines ...
    use(opt); // opt is OK
}

\end{minted}
\end{minipage}
\\ \midrule
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize =\footnotesize]{c++}

std::optional o{7};
if (o) {
    *o = 9;
    std::cout << "o=" << *o << " prints 9\n";
}
std::cout << "o=" << *o << " prints 9\n";

\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\footnotesize]{c++}

std::optional o{7};
for (auto&& i : views::nullable(std::ref(o))) {
    i = 9;
    std::cout << "i=" << i << " prints 9\n";
}
std::cout << "o=" << *o << " prints 9\n";

// if range for is too much magic
if (auto v = views::nullable(std::ref(o));
    std::begin(v) != std::end(v)) {
    auto itr = std::begin(v);
    *itr     = 10;
    std::cout << "*itr=" << *itr
              << " prints 10\n";
}
std::cout << "o=" << *o << " prints 10\n";

\end{minted}
\end{minipage}
\\ \midrule
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\footnotesize]{c++}
std::vector<int> v{2, 3, 4, 5, 6, 7, 8, 9, 1};
auto test = [](int i) -> std::optional<int> {
    switch (i) {
    case 1:
    case 3:
    case 7:
    case 9:
        return i;
    default:
        return {};
    }
};

auto&& r = v | ranges::views::transform(test) |
           ranges::views::filter(
               [](auto x) { return bool(x); }) |
           ranges::views::transform(
               [](auto x) { return *x; }) |
           ranges::views::transform([](int i) {
               std::cout << i;
               return i;
           });
for (auto&& i : r) {
};

\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\footnotesize]{c++}
std::vector<int> v{2, 3, 4, 5, 6, 7, 8, 9, 1};
auto test = [](int i) -> std::optional<int> {
    switch (i) {
    case 1:
    case 3:
    case 7:
    case 9:
        return i;
    default:
        return {};
    }
};

auto&& r =
    v | ranges::views::transform(test) |
    ranges::views::transform(views::nullable) |
    ranges::views::join |
    ranges::views::transform([](int i) {
        std::cout << i;
        return i;
    });
for (auto&& i : r) {
};

\end{minted}
\end{minipage}
\end{tabular}

\chapter{Motivation}

In writing range transformation it is useful to be able to lift a value into a view that is either empty or contains the value. For types that model \tcode{nullable_object}, constructing an empty view for disengaged values and providing a view to the underlying value is useful as well. The adapter \tcode{views::single} fills a similar purpose for non-nullable values, lifting a single value into a view, and \tcode{views::empty} provides a range of no values of a given type. The type \tcode{views::maybe} can be used to unify \tcode{single} and \tcode{empty} into a single type for further processing. This is in particuluar useful when translating list comprehensions.

\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}{c++}
std::vector<std::optional<int>> v{
    std::optional<int>{42},
    std::optional<int>{},
    std::optional<int>{6 * 9}};

auto r = views::join(
    views::transform(v, views::nullable));

for (auto i : r) {
    std::cout << i; // prints 42 and 54
}
  \end{minted}
\end{minipage}


In addition to range transformation pipelines, \mintinline{C++}{views::maybe} can be used in range based for loops, allowing the nullable value to not be dereferenced within the body. This is of small value in small examples in contrast to testing the nullable in an if statement, but with longer bodies the dereference is often far away from the test. Often the first line in the body of the \mintinline{C++}{if} is naming the dereferenced nullable, and lifting the dereference into the for loop eliminates some boilerplate code, the same way that range based for loops do.

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}
{
    auto opt = possible_value();
    if (opt) {
        // a few dozen lines ...
        use(*opt); // is *opt OK ?
    }
}

for (auto&& opt :
     views::nullable(possible_value())) {
    // a few dozen lines ...
    use(opt); // opt is OK
}

\end{minted}
\end{minipage}

The view can be on a \mintinline{C++}{std::reference_wrapper}, allowing the underlying nullable to be modified:

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}
std::optional o{7};
for (auto&& i : views::nullable(std::ref(o))) {
    i = 9;
    std::cout << "i=" << i << " prints 9\n";
}
std::cout << "o=" << *o << " prints 9\n";

\end{minted}
\end{minipage}

Of course, if the nullable is empty, there is nothing in the view to modify.

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}

auto oe = std::optional<int>{};
for (int i : views::nullable(std::ref(oe)))
    std::cout << "i=" << i
              << '\n'; // does not print

\end{minted}
\end{minipage}

Converting an optional type into a view can make APIs that return optional types, such a lookup operations, easier to work with in range pipelines.

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}

std::unordered_set<int> set{1, 3, 7, 9};

auto flt = [=](int i) -> std::optional<int> {
    if (set.contains(i))
        return i;
    else
        return {};
};

for (auto i : ranges::iota_view{1, 10} |
                  ranges::views::transform(flt)) {
    for (auto j : views::nullable(i)) {
        for (auto k : ranges::iota_view(0, j))
            std::cout << '\a';
        std::cout << '\n';
    }
}

\end{minted}
\end{minipage}


\chapter{Lazy monadic pythagorean triples}

Eric Niebler's pythagorean triple example, using current C++ and proposed \tcode{views::maybe}.

\begin{minipage}[t]{\columnwidth}
  \begin{minted}{c++}


// "and_then" creates a new view by applying a transformation to each element
// in an input range, and flattening the resulting range of ranges. A.k.a. bind

inline constexpr auto and_then = [](auto&& r, auto fun) {
    return decltype(r)(r) | std::ranges::views::transform(std::move(fun)) |
           std::ranges::views::join;
};

// "yield_if" takes a bool and a value and returns a view of zero or one
// elements.

inline constexpr auto yield_if = [](bool b, auto x) {
    return b ? maybe_view{std::move(x)} : maybe_view<decltype(x)>{};
};

void print_triples() {
    using std::ranges::views::iota;
    auto triples = and_then(iota(1), [](int z) {
        return and_then(iota(1, z + 1), [=](int x) {
            return and_then(iota(x, z + 1), [=](int y) {
                return yield_if(x * x + y * y == z * z,
                                std::make_tuple(x, y, z));
            });
        });
    });

    // Display the first 10 triples
    for (auto triple : triples | std::ranges::views::take(10)) {
        std::cout << '(' << std::get<0>(triple) << ',' << std::get<1>(triple)
                  << ',' << std::get<2>(triple) << ')' << '\n';
    }
}

\end{minted}
\end{minipage}

The implementation of \tcode{yield_if} is essentially the type unification of \tcode{single} and \tcode{empty} into \tcode{maybe}, returning an empty on false, and a range containing one value on true. I plan to propose this function for standardization in a following paper.

\chapter{Wait, There's More}
Having worked with the \tcode{reference_wrapper} support for some time, the ergonomics are somewhat lacking. In addition, many of the Big Dumb Business Objects that are the result of lookups, or filters, and are thus good candidates for optionality, are also not good at move operations, having dozens of individual members that are a mix of primitives, strings, and sub-BDOs, resulting in complex move constructors. In addition, many old and well tested functions will mutate these objects, rather than making copies, using a more object oriented style than a value oriented style.

For these reasons, supporting the common case of reference semantics ergonomically is important. Folding the implementation of \tcode{reference_wrapper} into a template specialization for \tcode{T\&} provides good ergonomics. Neither \tcode{view_maybe} or \tcode{view_nullable} support assignment from the underlying type, so the only question for semantics is assignment from another instance of the same type. The semantics of \tcode{std::reference_wrapper} are well established and correct, where the implementation pointer is reassigned, putting the assignee into the same state as the assigned. The same semantics are adopted for \tcode{view_maybe} or \tcode{view_nullable}.

The owning view \tcode{view_maybe} is not a container, and does not try to support the full container interface. As a range with a fixed upper size, emplace and push back operations are problematic. Not supplying them is not problematic.

This means that all of the operations on \tcode{view_maybe} and \tcode{view_nullable} are directly safe. To construct a non-safe operation is possible, but looks unsafe in code. For example:

\begin{minipage}[t]{\columnwidth}
  \begin{minted}{c++}
maybe_view<int> o1{42};
assert(*(o1.data()) == 42));
  \end{minted}
\end{minipage}

Dereferencing the result of \tcode{data()} without a check for null is of course unsafe, but in a way that should be visibile to both programmers and tools.

Now, \tcode{view_maybe} is a models an optional type very much the same wayt that \tcode{std::optional} does, and in fact the reference implementation holds the value of the maybe in an \tcode{std::optional}, so this suggests that \tcode{view_maybe} should have the monadic interface of \tcode{std::optional}, in addition to the monadic range interface. The member functions are much more strongly typed than the monad in the range category, staying within the template type. However, it is not feasible to give \tcode{view_nullable} the same monadic interface as it would require, for example,  construction of an type that dereferences to U to support transform over T -> U, but that is not in general possible in the C++ type system. The additional level of indirection built in to \tcode{view_nullable} makes this infeasible. The inconistency of implementablility supports the direction from SG9 to separate the templates by name, rather than just by concept.

Providing the monadic interface on the reference specialization of \tcode{view_nullable} is entirely straight-forward.

The range adaptors, \tcode{views::maybe} and \tcode{views::nullable}, only produce the non-reference specialization. As range code is strongly rooted in value sematics, providing reference semantics without ceremony seems potentially dangerous. If the pattern becomes common, providing an instance of the function object with a distinct name would be non-breaking for anyone.

Looking at the test code for the reference implementation, we can see that usage for the non-reference specialization is very similar:

\begin{minipage}[t]{\linewidth}
  \begin{minted}{c++}
maybe_view<int> mv{40};
auto            r = mv.and_then([](int i) { return maybe_view{i + 2}; });
ASSERT_TRUE(!r.empty());
ASSERT_TRUE(r.size() == 1);
ASSERT_TRUE(r.data() != nullptr);
ASSERT_TRUE(*(r.data()) == 42);
ASSERT_TRUE(!mv.empty());
ASSERT_TRUE(*(mv.data()) == 40);

auto r2 = mv.and_then([](int) { return maybe_view<int>{}; });
ASSERT_TRUE(r2.empty());
ASSERT_TRUE(r2.size() == 0);
ASSERT_TRUE(r2.data() == nullptr);
ASSERT_TRUE(!mv.empty());

\end{minted}
\end{minipage}

A test stanza for the \tcode{T\&} case suggests more interesting applications:

\begin{minipage}[t]{\linewidth}
  \begin{minted}{c++}

int              forty{40};
maybe_view<int&> mv{forty};
auto             r9 = mv.transform([](int& i) {
    int k = i;
    i     = 56;
    return k * 2;
});

ASSERT_TRUE(!r9.empty());
ASSERT_EQ(r9.size(), 1);
ASSERT_TRUE(r9.data() != nullptr);
ASSERT_EQ(*(r9.data()), 80);
ASSERT_TRUE(!mv.empty());
ASSERT_EQ(*(mv.data()), 56);
ASSERT_EQ(forty, 56);
forty = 40;

\end{minted}
\end{minipage}

Introducing a new optionalish type may provide a way out of the \tcode{std::optional<T\&>} quagmire. There is no risk of broken code or changes in SFINAE. The type \tcode{view_maybe} is not useful as a default parameter or a subsitute for its underlying type. It behaves the same way that \tcode{std::reference_wrapper} has for more than a decade. Maybe as a name is common in the area for these sorts of types, it is not innovative.

In order to affect the underlying referenced type, not only do we need to use \tcode{maybe_view<int\&>} explicitly, the function passed to \tcode{transform} must take the underlying type by reference. A significant amount of ceremony is required. Since the general direction has been and continues to be in favor of value oriented programming, making mutation require a context in a lonely place is appropriate.


\chapter{Proposal}
Add two range adaptor objects
\begin{itemize}
\item
  \tcode{views::maybe} a range adaptor that produces an owning view holding $0$ or $1$ elements of an object.
\item
  \tcode{views::nullable} a range adaptor over a \tcode{nullable_object} producing a view into the nullable object.
\end{itemize}

A \tcode{nullable_object} object is one that is both contextually convertible to bool and for which the type produced by dereferencing is an equality preserving object. Non void pointers, \tcode{std::optional}, and the proposed \tcode{std::expected} \cite{P0323R9} types all model \exposid{nullable_object}. Function pointers do not, as functions are not objects. Iterators do not generally model \exposid{nullable}, as they are not required to be contextually convertible to bool.

The generic types \tcode{std::view_maybe} and \tcode{std::view_nullable}, which are produced by \tcode{views::maybe} and \tcode{views::nullable}, respectively, are further specialized over reference types, such that operations on the iterators of the range modify the object the range is over, if and only if the object exists.

\chapter{Borrowed Range}
A \tcode{borrowed_range} is one whose iterators cannot be invalidated by ending the lifetime of the range. For \tcode{views::maybe} and \tcode{views::nullable} iterators are \tcode{T*}, where \tcode{T} is essentially the type of the underlying object. For \tcode{view_nullable} or \tcode{view_maybe} over raw pointers and \tcode{std::reference_wrapper} the iterators  point directly to the underlying object, and thus matches the semantics of \libconcept{borrowed_range}.

For the reference specializations, all types imply a borrowed range.

A \tcode{maybe_view<shared_ptr>}, however, is not a borrowed range, as it participates in ownership of the \tcode{shared_ptr} and might invalidate the iterators if upon the end of its lifetime it is the last owner.

An example of code that is enabled by borrowed ranges, if unlikely code:

\begin{minipage}[t]{\columnwidth}
\begin{minted} {c++}
num = 42;
int k = *std::ranges::find(views::maybe(&num), num);
\end{minted}
\end{minipage}

Providing the facility is not a signficant cost, and conveys the semantics correctly, even if the simple examples are not hugely motivating. Particularly as there is no real implementation impact, other than providing template variable specializations for enable_borrowed_range.

\chapter{Design}
For \tcode{views_maybe} the design is a hybrid of view_empty and view_single, with the straight forward extention for reference type, refering to an existing object. For \tcode{views_nullable} we have the same sematics of zero or one objects, only based on if the underlying nullable object does or does not have a value.

\chapter{Freestanding}

Both \tcode{views_maybe} and \tcode{views_nullable} naturally meet the requirements for freestanding. The expository use of \tcode{optional} does not interfere with the ability of \tcode{views_maybe} to meet the requirements of freestanding.


\chapter{Implementation}

A publically available implementation at \url{https://github.com/steve-downey/view_maybe} based on the Ranges implementation in libstdc++. There are no particular implementation difficulties or tricks. The declarations are essentially what is quoted in the Wording section and the implementations are described as effects.

\href{https://godbolt.org/\#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI\%2BAEaYxCDSAA6oCoRODB7evnoJSY4CQSHhLFEx0naYDilCBEzEBGk\%2Bfly2mPY5DJXVBHlhkdGxtlU1dRmNCgOdwd2FvZIAlLaoXsTI7BzmAMzByN5YANQma24IBARxCiAA9OfETADuAHTAhAheEV5KS7KMBHdoLOejmAAbpgALToVA3EIAT3OgLwmBuAH0WEwoVFziiAcR/ktYfCkSi0Zg8QjkaioncEPtsCYNABBWkMswbBhbLy7fZuYEOEjUxmM0boEAgVBxVpiTnBAjUnZZJIReiIwFiLyYCAzfZWemA1B4dA7N5qqU7AgatZauk6vU7KL8YiYDTq/kAdgtO3de1djI9OyYXiI5gAbEGdqKCHs1gARWWJeWK5XeNVmt0evBUHYQMMzPb0n0mL25n0ey6\%2BnZUBE7cEAL0YO1oEwUOzuze9RfdhogACos5qdiW8I3u2KdgB5ADSEYAYq33fnIzPPfP6XP\%2BdrdfqmFQCNFHdmXRa7Rm/QGzMHT6HhyAdnCEWcQISohA5XgFZglSqkzM98uC3SfSWmDLCtq1resQkbZs7gXDse3NPtzgvcMB1HMcXSXBlnXQxkrX1W0SEwLh1RzDCLUFYUwxSMRQ3zCxnRXc1GTTDNUG/EiF27CNowATk1BcyJQBZw05Tk9jMMxUH2ecxIjNwRI44SDlEsxZWIKVGx4gBWNwGHMMxeJ/dD\%2BLQf0ZJE3SJKjXTTMU\%2BSDjM6S4lUwR1JMLSdLE/SMKwtdrU3bdiEI1iaIFAghRFMVKNoajXTozDPMPCBjwk08QzwHYrxvG47wfNV\%2BPtKhMy/ILfx9NLJJ2HiGMLd0jME6y3CUvBJKshSGrKuzFKsxy1Iq1ztN0zyV3pWqTNapSLKk5Sxts2TOocpyCBctyBqqrzV0tdcbUwO1MDMJ0f1I0LhW5IhiElQQZUBGizFIHY1lu6Qdg027A1u51boADlurjbq4eiLSSk1MFGTi9g0qwNMjCBjTwbMQRlfiKIECUDilGVguqnYFBuQhkAQDNYc9FMfVEJQdi4EAF3dUnMDuynMeppgyedem/yLGmKtZn17QIRYGB2JrVrbLAqD9WgCC5j0eb5on/oXIa1tWxkkqDENiFBwFPVkzHriMYHjvxO8CF1hQ7RYCBt1GPdnW1tn3V14B9ZATK7xocXoggVyIahwHVA1V1peIfmIlQTwID93jMOt23ucMR27xd4VjcMU2SHNr3XJ9/1UB2COA8wXmg52TtVEjyNo4XB2ncTkBk4YVPiHThmPQzyHocEAXreJtsPRGoSOrazye6LQP\%2BcF7u8yj\%2BKSCPbPVfPNKr2ILu5eXAz1pw30t2iPaNQOkKwpO3lUYutZsGva7bvunZHuenZXp2d6di\%2BirftXulAct/vo1bqGYbhhGR1wriloOdaUZ9ZaY2xrjfG0MV7Nw5hTKmOwOZrEliTJmtMWbII5lxdBOxR4CyHkWEWYsJaVwLjLYKcUhYtziuvJW9IVYpXPOrcqmt8wxylnHauhsk4mzNhbYGpotaVx4QnPhtcBFpwgDXHKFcdbiINreYU2hdT804WIvWEiVFSJToI5Bs5waZ3bkheBdth5YyAcZfus1B60MsQQyhRdx6GMXMmRkCVmFnkDALdKBCV40ItHODgcxaCcA0rwPwHAtCkFQJwWSlhrBYwWEsWm6weCkAljE0JcwECYCYFgGI6pSAAGsQAaQ0PoTgkgomaF4PEjgvAzhVOyVoOYcBYAwEQAJFgcQ6DRHIJQX4/T6AxGAAoZgpwECoAIHwOg/kzgQAiPU0gERgjVChJwTJvw2CCBHAwWgWycmkCwCiIw4gTn4HtOUYEZwTmYFUGUf0KxYlSmaKs\%2BsERrjEChB4LA2zeDGzwCwQFcwqAGAmQANXxCOOIjBAUyEECIMQ7ApBIvkEoNQqzdCNAMEYFA1hrD6BfGcWAzA2AoBYMgUYtAbrAhiMbLwDBSlfjiRFAQ9yQQgkFJJUwSTLBmA0DsEEI41jNOaGUVoLgGDuE8PUfwsqugFCKJkRIyQBBDAaKQLIGqGDKp6DEEYkrygCHaIMeVwwmgtAqGMA1UwjX9A6FqvQowOj2tVVwOYChUnLD0MbTAKweBhIiXUk5jTVAfUDCCQMkgdjAGQMgDMTKWXZggIkqwlhbq4EIDPDJt0PB9IGWw5kXqgX1LZeUyp1SOC1NIKC6t0TYmNOaSAVpFbSCdJ6YJOI/ohkQEwPgU6eo9D8GRaIcQ6Kx2YpUOoE5uLSA3GuHEMFNbImkCbQ0zgI5/S9vDKgdMkbo2xvjYm5NxBmWsozIW0Z0RRJrDLVkiteSClFMoCG2tvAG1VM3XEzgrb205MrRUqp4SODio3asltT6gMfrMGG5t/6YPtLmAypIzhJBAA\%3D}{Compiler
  Explorer Link to Before/After Examples}

The implementation, for exposition purposes, uses \tcode{std::optional} to hold the value for \tcode{views_maybe}. Implementations, to reduce the overhead of debugging implementations should probably hoist the storage and flag in a typical optional into \tcode{views_maybe}, in which case the flag should be checked first on reads with acquire/release atomic semantics, and last on writes, so as to provide a synchronization pointe. Although this note may be in the close neighborhood of teaching my grandmother to suck eggs.

\chapter{Wording}
\begin{wording}


Modify 26.2 Header <ranges> synopsis

\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{adjustwidth}{1cm}{1cm}
  \begin{addedblock}
    \begin{codeblock}
// \ref{range.maybe}, maybe view
template<copy_constructible T>
requires @\seebelow@;
class maybe_view;                                              // freestanding

template <typename T>
constexpr inline bool
enable_borrowed_range<maybe_view<T*>> = true;                  // freestanding

template <typename T>
constexpr inline bool
enable_borrowed_range<maybe_view<reference_wrapper<T>>> = true; // freestanding

template <typename T>
constexpr inline bool
enable_borrowed_range<maybe_view<T&>> = true;                  // freestanding

namespace views {
  inline constexpr @\unspec@ maybe = @\unspec@;           // freestanding
}

// \ref{range.nullable}, nullable view
template<copy_constructible T>
requires @\seebelow@;
class nullable_view;                                           // freestanding

template <typename T>
constexpr inline bool
enable_borrowed_range<nullable_view<T*>> = true;               // freestanding

template <typename T>
constexpr inline bool
enable_borrowed_range<nullable_view<reference_wrapper<T>>> = true;// freestanding

template <typename T>
constexpr inline bool
enable_borrowed_range<nullable_view<T&>> = true;                // freestanding

namespace views {
  inline constexpr @\unspec@ nullable = @\unspec@;        // freestanding
}



    \end{codeblock}
  \end{addedblock}
\end{adjustwidth}

\Sec2[range.maybe]{Maybe View}

\Sec3[range.maybe.overview]{Overview}

\pnum
\tcode{maybe_view} is a range adaptor that produces a \libconcept{view} with cardinality 0 or 1. It adapts \libconcept{copyable} object types.


\pnum
\indexlibrarymember{maybe}{views}%
The name \tcode{views::maybe} denotes a
customization point object\iref{customization.point.object}.
Given a subexpression \tcode{E}, the expression
\tcode{views::maybe(E)} is expression-equivalent to
\tcode{maybe_view<decay_t<decltype((E))>>(E)}.

The name \tcode{views::maybe} denotes a customization point object ([customization.point.object]). For some subexpression \tcode{E}, the expression \tcode{views::maybe<E>} is expression-equivalent to:
\begin{itemize}
\item
  \tcode{maybe_view(E)}, the \libconcept{view} specified below, if the expression is well formed, where \tcode{\placeholdernc{decay-copy}(E)} is moved into the \tcode{maybe_view}
\item
 otherwise \tcode{views::maybe(E)} is ill-formed.
\end{itemize}


\begin{note}
  Whenever \tcode{views::maybe(E)} is a valid expression, it is a prvalue whose type models \libconcept{view}.
\end{note}
\pnum

\begin{example}
  \begin{codeblock}
  int i{4};
  maybe_view m{i};
  for (int k : m) {
    cout << k;        // prints 4
  }

  maybe_view<int> m2{};
  for (int k : m2) {
    cout << k;        // Does not execute
  }
\end{codeblock}
\end{example}

\Sec3[range.maybe.view]{Class template \tcode{maybe_view}}

\begin{codeblock}

template <typename Value>
class maybe_view;

template <typename Value>
inline constexpr bool is_maybe_view_v = false;
template <typename Value>
inline constexpr bool is_maybe_view_v<maybe_view<Value>> = true;

template <typename Value>
class maybe_view : public ranges::view_interface<maybe_view<Value>> {
  private:
    std::optional}<Value> @\exposidnc{value_}@;             // \expos{}

  public:
    constexpr maybe_view() requires @\libconcept{default_initializable}@<Value> = default;
    constexpr explicit maybe_view(Value const& value);
    constexpr explicit maybe_view(Value&& value);

    template <class... Args>
      requires @\libconcept{constructible_from}@<Value, Args...>
    constexpr maybe_view(std::in_place_t, Args&&... args);

    constexpr Value*       begin() noexcept;
    constexpr const Value* begin() const noexcept;
    constexpr Value*       end() noexcept;
    constexpr const Value* end() const noexcept;

    constexpr size_t size() const noexcept;

    constexpr Value* data() noexcept;

    constexpr const Value* data() const noexcept;

    friend constexpr auto operator<=>(const maybe_view& lhs,
                                      const maybe_view& rhs);

    friend constexpr bool operator==(const maybe_view& lhs,
                                     const maybe_view& rhs);

    template <typename F>
    constexpr auto and_then(F&& f) &;
    template <typename F>
    constexpr auto and_then(F&& f) &&;
    template <typename F>
    constexpr auto and_then(F&& f) const&;
    template <typename F>
    constexpr auto and_then(F&& f) const&&;

    template <typename F>
    constexpr auto transform(F&& f) &;
    template <typename F>
    constexpr auto transform(F&& f) &&;
    template <typename F>
    constexpr auto transform(F&& f) const&;
    template <typename F>
    constexpr auto transform(F&& f) const&&;

    template <typename F>
    constexpr auto or_else(F&& f) &&;
    template <typename F>
    constexpr auto or_else(F&& f) const&;
};

\end{codeblock}

%% BEGIN value defs
\begin{itemdecl}
  constexpr explicit maybe_view(Value const& maybe);
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes \exposid{value_} with maybe.
\end{itemdescr}

\begin{itemdecl}
  constexpr explicit maybe_view(Value&& maybe);
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes \exposid{value_} with \tcode{std::move(maybe)}.
\end{itemdescr}

\begin{itemdecl}
  template<class... Args>
  constexpr maybe_view(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects
  Initializes \exposid{value_} as if by
  \tcode{\exposid{value_}\{in_place, std::forward<Args>(args)...\}}.
\end{itemdescr}

\begin{itemdecl}
  constexpr T* begin() noexcept;
  constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to: \tcode{return data();}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* end() noexcept;
  constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{data() + size();}.
\end{itemdescr}

\begin{itemdecl}
  static constexpr size_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    return bool(@\exposid{value_}@);
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* data() noexcept;
  constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{std::addressof(*@\exposid{value_}@);}
\end{itemdescr}

\begin{itemdecl}
  constexpr auto operator<=>(const maybe_view& lhs, const maybe_view& rhs)
  \end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{lhs.value_} <=> \tcode{rhs.value_};
\end{itemdescr}

\begin{itemdecl}
  constexpr auto operator==(const maybe_view& lhs, const maybe_view& rhs)
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{lhs.value_} == \tcode{rhs.value_};
\end{itemdescr}


\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), *@\exposid{value_}@);
    } else {
      return std::remove_cvref_t<U>();
    }  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), std::move(*@\exposid{value_}@));
    } else {
      return std::remove_cvref_t<U>();
    }
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), *@\exposid{value_}@);
    } else {
      return std::remove_cvref_t<U>();
    }
  \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) const&&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), std::move(*@\exposid{value_}@));
    } else {
      return std::remove_cvref_t<U>();
    }
  \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f), *@\exposid{value_}@)}
    : maybe_view<U>{};
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f),
      std::move(*@\exposid{value_}@))}
    : maybe_view<U>{};

  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f), *@\exposid{value_}@)}
    : maybe_view<U>{};

  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) const&&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f),
      std::move(*@\exposid{value_}@))}
    : maybe_view<U>{};

  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto or_else(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F>;
    static_assert(std::is_same_v<std::remove_cvref_t<U>, maybe_view>);
    return @\exposid{value_}@ ? *this : std::forward<F>(f)();

  \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
  template <typename F>
  constexpr auto or_else(F&& f) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F>;
    static_assert(std::is_same_v<std::remove_cvref_t<U>, maybe_view>);
    return @\exposid{value_}@ ? std::move(*this) : std::forward<F>(f)();

  \end{codeblock}
\end{itemdescr}

\begin{codeblock}

  template <typename Value>
  class maybe_view<Value&> : public ranges::view_interface<maybe_view<Value&>> {
    private:
    Value* @\exposidnc{value_}@;             // \expos{}

    public:
    constexpr maybe_view();

    constexpr explicit maybe_view(Value& value);

    constexpr explicit maybe_view(Value&& value) = delete;

    constexpr Value*       begin() noexcept;
    constexpr const Value* begin() const noexcept;
    constexpr Value*       end() noexcept;
    constexpr const Value* end() const noexcept;

    constexpr size_t size() const noexcept;

    constexpr Value* data() noexcept;

    constexpr const Value* data() const noexcept;

    friend constexpr auto operator<=>(const maybe_view& lhs,
    const maybe_view& rhs) {
      return (bool(lhs.value_) && bool(rhs.value_))
      ? (*lhs.value_ <=> *rhs.value_)
      : (bool(lhs.value_) <=> bool(rhs.value_));
    }

    friend constexpr bool operator==(const maybe_view& lhs,
    const maybe_view& rhs) {
      return (bool(lhs.value_) && bool(rhs.value_))
      ? (*lhs.value_ == *rhs.value_)
      : (bool(lhs.value_) == bool(rhs.value_));
    }

    template <typename F>
    constexpr auto and_then(F&& f) &;
    template <typename F>
    constexpr auto and_then(F&& f) &&;
    template <typename F>
    constexpr auto and_then(F&& f) const&;
    template <typename F>
    constexpr auto and_then(F&& f) const&&;
    template <typename F>

    constexpr auto transform(F&& f) &;
    template <typename F>
    constexpr auto transform(F&& f) &&;
    template <typename F>
    constexpr auto transform(F&& f) const&;
    template <typename F>
    constexpr auto transform(F&& f) const&&;
    template <typename F>

    constexpr maybe_view or_else(F&& f) &&;
    template <typename F>
    constexpr maybe_view or_else(F&& f) const&;
  };

\end{codeblock}

\begin{itemdecl}
  constexpr explicit maybe_view();
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes \exposid{value_} with \tcode{nullptr}
\end{itemdescr}

\begin{itemdecl}
  constexpr explicit maybe_view(Value maybe);
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes \exposid{value_} with \tcode{addressof(maybe)}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* begin() noexcept;
  constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to: \tcode{return data();}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* end() noexcept;
  constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{data() + size();}.
\end{itemdescr}

\begin{itemdecl}
  static constexpr size_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    return bool(@\exposid{value_}@);
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* data() noexcept;
  constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    if (!@\exposid{value_}@)
        return nullptr;
    return std::addressof(*@\exposid{value_}@);

  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), *@\exposid{value_}@);
    } else {
      return std::remove_cvref_t<U>();
    }
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), std::move(*@\exposid{value_}@));
    } else {
      return std::remove_cvref_t<U>();
    }
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), *@\exposid{value_}@);
    } else {
      return std::remove_cvref_t<U>();
    }
  \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
  template <typename F>
  constexpr auto and_then(F&& f) const&&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&&>;
    static_assert(is_maybe_view_v<std::remove_cvref_t<U>>);
    if (@\exposid{value_}@) {
      return std::invoke(std::forward<F>(f), std::move(*@\exposid{value_}@));
    } else {
      return std::remove_cvref_t<U>();
    }
  \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f), *@\exposid{value_}@)}
    : maybe_view<U>{};

  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, Value&&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f),
      std::move(*@\exposid{value_}@))}
    : maybe_view<U>{};

  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f), *@\exposid{value_}@)}
    : maybe_view<U>{};

  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto transform(F&& f) const&&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F, const Value&&>;
    return (@\exposid{value_}@) ? maybe_view<U>{std::invoke(std::forward<F>(f),
      std::move(*@\exposid{value_}@))}
    : maybe_view<U>{};
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  template <typename F>
  constexpr auto or_else(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F>;
    static_assert(std::is_same_v<std::remove_cvref_t<U>, maybe_view>);
    return @\exposid{value_}@ ? *this : std::forward<F>(f)();
  \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
  template <typename F>
  constexpr auto or_else(F&& f) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    using U = std::invoke_result_t<F>;
    static_assert(std::is_same_v<std::remove_cvref_t<U>, maybe_view>);
    return @\exposid{value_}@ ? std::move(*this) : std::forward<F>(f)();

  \end{codeblock}
\end{itemdescr}


\Sec2[range.nullable]{Nullable View}

\Sec3[range.nullable.overview]{Overview}

\pnum
\tcode{nullable_view} is a range adaptor that produces a \libconcept{view} with cardinality 0 or 1. It adapts \libconcept{copyable} object types which model the exposition only concept \libconcept{nullable_object_val} or \libconcept{nullable_object_ref}.


\pnum
\indexlibrarymember{nullable}{views}%
The name \tcode{views::nullable} denotes a
customization point object\iref{customization.point.object}.
Given a subexpression \tcode{E}, the expression
\tcode{views::nullable(E)} is expression-equivalent to
\tcode{nullable_view<decay_t<decltype((E))>>(E)}.

The name \tcode{views::nullable} denotes a customization point object ([customization.point.object]). For some subexpression \tcode{E}, the expression \tcode{views::nullable<E>} is expression-equivalent to:
\begin{itemize}
\item
  \tcode{nullable_view(E)}, the \libconcept{view} specified below, if the expression is well formed, where \tcode{\placeholdernc{decay-copy}(E)} is moved into the \tcode{nullable_view}
\item
  otherwise \tcode{views::nullable(E)} is ill-formed.
\end{itemize}


\begin{note}
  Whenever \tcode{views::nullable(E)} is a valid expression, it is a prvalue whose type models \libconcept{view}.
\end{note}
\pnum

\Sec3[range.nullable.view]{Class template \tcode{nullable_view}}

\begin{example}
  \begin{codeblock}
    std::optional o{4};
    nullable_view m{o};
    for (int k : m) {
      cout << k;        // prints 4
    }
  \end{codeblock}
\end{example}

\Sec3[range.nullable.view]{Class template \tcode{nullable_view}}

\begin{codeblock}

template <typename Nullable>
    requires(copyable_object<Nullable> &&
             (nullable_object_val<Nullable> || nullable_object_ref<Nullable>))
class nullable_view<Nullable>
    : public ranges::view_interface<nullable_view<Nullable>> {
  private:
    using T = std::remove_reference_t<
        std::iter_reference_t<typename std::unwrap_reference_t<Nullable>>>;

    ranges::__detail::__box<Nullable> value_;

  public:
    constexpr nullable_view() = default;

    constexpr explicit nullable_view(Nullable const& nullable);

    constexpr explicit nullable_view(Nullable&& nullable);

    template <class... Args>
        requires std::constructible_from<Nullable, Args...>
    constexpr nullable_view(std::in_place_t, Args&&... args);

    constexpr auto begin() noexcept;
    constexpr auto begin() const noexcept;
    constexpr auto end() noexcept;
    constexpr auto end() const noexcept;

    constexpr size_t size() const noexcept;

    constexpr auto data() noexcept;

    constexpr const auto data() const noexcept;

    friend constexpr auto operator<=>(const nullable_view& l,
                                      const nullable_view& r) {
        const Nullable& lhs = *l.value_;
        const Nullable& rhs = *r.value_;
        if constexpr (is_reference_wrapper_v<Nullable>) {
            return (bool(lhs.get()) && bool(rhs.get()))
                       ? (*(lhs.get()) <=> *(rhs.get()))
                       : (bool(lhs.get()) <=> bool(rhs.get()));
        } else {
            return (bool(lhs) && bool(rhs)) ? (*lhs <=> *rhs)
                                            : (bool(lhs) <=> bool(rhs));
        }
    }

    friend constexpr bool operator==(const nullable_view& l,
                                     const nullable_view& r) {
        const Nullable& lhs = *l.value_;
        const Nullable& rhs = *r.value_;

        if constexpr (is_reference_wrapper_v<Nullable>) {
            return (bool(lhs.get()) && bool(rhs.get()))
                       ? (*(lhs.get()) == *(rhs.get()))
                       : (bool(lhs.get()) == bool(rhs.get()));
        } else {
            return (bool(lhs) && bool(rhs)) ? (*lhs == *rhs)
                                            : (bool(lhs) == bool(rhs));
        }
    }
};

\end{codeblock}

WORDING for nullable funcs

\begin{codeblock}
template <typename Nullable>
    requires(copyable_object<Nullable> &&
             (nullable_object_val<Nullable> || nullable_object_ref<Nullable>))
class nullable_view<Nullable&>
    : public ranges::view_interface<nullable_view<Nullable>> {
  private:
    using T = std::remove_reference_t<
        std::iter_reference_t<typename std::unwrap_reference_t<Nullable>>>;

    Nullable* value_;

  public:
    constexpr nullable_view() : value_(nullptr){};

    constexpr explicit nullable_view(Nullable& nullable)
        : value_(std::addressof(nullable)) {}

    constexpr explicit nullable_view(Nullable&& nullable) = delete;

    constexpr T*       begin() noexcept { return data(); }
    constexpr const T* begin() const noexcept { return data(); }
    constexpr T*       end() noexcept { return data() + size(); }
    constexpr const T* end() const noexcept { return data() + size(); }

    constexpr size_t size() const noexcept {
        if (!value_)
            return 0;
        Nullable& m = *value_;
        if constexpr (is_reference_wrapper_v<Nullable>) {
            return bool(m.get());
        } else {
            return bool(m);
        }
    }

    constexpr T* data() noexcept {
        if (!value_)
            return nullptr;
        Nullable& m = *value_;
        if constexpr (is_reference_wrapper_v<Nullable>) {
            return m.get() ? std::addressof(*(m.get())) : nullptr;
        } else {
            return m ? std::addressof(*m) : nullptr;
        }
    }

    constexpr const T* data() const noexcept {
        if (!value_)
            return nullptr;
        const Nullable& m = *value_;
        if constexpr (is_reference_wrapper_v<Nullable>) {
            return m.get() ? std::addressof(*(m.get())) : nullptr;
        } else {
            return m ? std::addressof(*m) : nullptr;
        }
    }
};

\end{codeblock}

WORDING for nullable ref funcs


\Sec2[version.syn]{Feature-test macro}
Add the following macro definition to [version.syn], header <version> synopsis, with the value selected by the editor to reflect the date of adoption of this paper:

\begin{codeblock}
  #define __cpp_lib_ranges_maybe 20XXXXL // also in <ranges>, <tuple>, <utility>
\end{codeblock}

\end{wording}

\chapter{Impact on the standard}

A pure library extension, affecting no other parts of the library or language.

The proposed changes are relative to the current working draft~\cite{N4910}.

\chapter*{Document history}

\begin{itemize}
\item \textbf{Changes since R8},
  \begin{itemize}
  \item Give maybe and nullable distinct template names
  \item Propose T\& specializations
  \item Propose monadic interface for view_maybe
  \item Wording
  \item Freestanding
  \end{itemize}
\item \textbf{Changes since D7}, presented to SG9 on 2022.07.11
  \begin{itemize}
  \item Layout issues
  \item References include paper source
  \item Citation abbreviation form to `abstract'
  \item `nuulable' typo fix
  \item Markdown backticks to tcode
  \item ToC depth and chapter numbers for Ranges
  \item No technical changes to paper --- all presentation
  \end{itemize}
\item \textbf{Changes since R7}
  \begin{itemize}
  \item Update all Wording.
  \item Convert to standards latex macros for wording.
  \item Removed discussion of list comprehension desugaring - will move to yield_if paper.
  \end{itemize}
\item \textbf{Changes since R6}
  \begin{itemize}
  \item Extend to all object types in order to support list comprehension
  \item Track working draft changes for Ranges
  \item Add discussion of _borrowed_range_
  \item Add an example where pipelines use references.
  \item Add support for proxy references (explore std::pointer_traits, etc).
  \item Make std::views::maybe model std::ranges::borrowed_range if it's not holding the object by value.
  \item Add a const propagation section discussing options, existing precedent and proposing the option that the author suggests.
  \end{itemize}
\item \textbf{Changes since R5}
  \begin{itemize}
  \item Fix reversed before/after table entry
  \item Update to match C++20 style [@N4849] and changes in Ranges since [@P0896R3]
  \item size is now size_t, like other ranges are also
  \item add synopsis for adding to `<ranges>` header
  \item Wording clean up, formatting, typesetting
  \item Add implementation notes and references
  \end{itemize}
\item \textbf{Changes since R4}
  \begin{itemize}
  \item Use std::unwrap\_reference
  \item Remove conditional `noexcept`ness
  \item Adopted the great concept renaming
  \end{itemize}
\item \textbf{Changes since R3}
  \begin{itemize}
  \item Always Capture
  \item Support reference\_wrapper
  \end{itemize}
\item \textbf{Changes since R2}
  \begin{itemize}
  \item Reflects current code as reviewed
  \item Nullable concept specification
  \item Remove Readable as part of the specification, use the useful requirements from Readable
  \end{itemize}
  \begin{itemize}
  \item Wording for views::maybe as proposed
  \item Appendix A: wording for a view\_maybe that always captures
  \end{itemize}
\item \textbf{Changes since R1}
  \begin{itemize}
  \item Refer to views::all
  \item Use wording 'range adaptor object'
  \end{itemize}
\item \textbf{Changes since R0}
  \begin{itemize}
  \item Remove customization point objects
  \item Concept `Nullable`, for exposition
  \item Capture rvalues by decay copy
  \item Remove maybe\_view as a specified type
  \end{itemize}
\end{itemize}

\renewcommand{\bibname}{References}
\bibliographystyle{abstract}
\bibliography{wg21,mybiblio}

\nocite{viewmayb27:online}

\end{document}
